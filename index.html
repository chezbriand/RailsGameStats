<!DOCTYPE html>
<html>
<head>
    <title>Game Analyzer</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.3.1"></script>
</head>
<body>
    <div style="display: flex; align-items: flex-start;">
        <img src="GameAnalyzerGraphic.png" alt="Image of a cartoon man playing a crayon rail game" style="width: 64px; height: 64px;">
        <div style="margin-left: 10px;">
          <p style="margin: 0;"><a href="https://github.com/chezbriand/RailsGameStats/">Rail Game Analyzer</a> v<span id="versionDisplay"></span> </p>
          <p style="margin-top: 8px;"><a href="https://github.com/chezbriand/RailsGameStats/issues">Report Issues or Make Feature Requests</a></p>
        </div>
    </div>

    <script>
        // Read the metadata.json file (adjust the path as needed)
        fetch('metadata.json')
            .then(response => response.json())
            .then(metadata => {
                
                // Construct the displayable version string
                const displayableVersion = `${metadata.buildMajor}.${metadata.buildMinor}.${metadata.buildRevision} ${metadata.buildTag}`;
                // Construct the displayable build time string
                const displayableBuildTime = `Build Time: ${metadata.buildTime}`;
                // Update the span element with the version
                document.getElementById('versionDisplay').textContent = displayableVersion + " " + displayableBuildTime;
            })
            .catch(error => console.error('Error reading metadata:', error));
    </script>

    <textarea id="inputArea" rows="10" cols="80" placeholder="Paste Game History here..."></textarea><br>
    Game Board: 
    
    <select id="startingMoney" onchange="updateValue()">
        <option value="60">AfricanRails</option>
        <option value="50">AustralianRails</option>
        <option value="50">AustralianRails2005</option>
        <option value="50">AustralianRailsVariant</option>
        <option value="60">BritishRails</option>
        <option value="60">ChinaRails</option>
        <option value="50">EmpireBuilder</option>
        <option value="50">EmpireBuilder2009</option>
        <option value="40">EmpireBuilderClassic</option>
        <option value="50">EuroRails</option>
        <option value="50">EuroRails2002</option>
        <option value="50">EuroRails2002CardVariant</option>
        <option value="50">EuroRails2002Variant</option>
        <option value="50">EuroRails2009</option>
        <option value="50">IndiaRails</option>
        <option value="60">IronDragon</option>
        <option value="60">IronDragon2017</option>
        <option value="60">IronDragonVariant</option>
        <option value="60">LunarRails</option>
        <option value="60">MartianRails</option>
        <option value="50">NipponRails</option>
        <option value="50">NipponRails2011</option>
        <option value="60">RussianRails</option>
        <option value="50">SouthAmericanRails</option>
    </select>
    Starting Money: <span id="displayValue">60</span> &nbsp;
       
    <script>
    function updateValue() {
        var selectedValue = document.getElementById('startingMoney').value;
        document.getElementById('displayValue').textContent = selectedValue;
    }
    </script>
    
    <button onclick="analyzeGame()">Analyze</button>
    <div id="stats" style="background-color: rgb(243, 212, 155); padding: 5px;"></div>
    <canvas id="myChart"></canvas>
    <button id="toggle-annotations">Toggle Annotations</button>

    <script>
        
        var myGameChart = null;

        function parseAmount(action) {
            var match = action.match(/\$(\d+)/);
            return match ? parseInt(match[1]) : 0;
        }

        function parseSegments(action) {
            var match = action.match(/Built (\d+) segments/);
            return match ? parseInt(match[1]) : 0;
        }

        function parseMovement(action) {
            var match = action.match(/Moved (\d+) spaces/);
            return match ? parseInt(match[1]) : 0;
        }

        function analyzeGame() {
            var text = document.getElementById('inputArea').value;
            var startingMoney = parseInt(document.getElementById('startingMoney').value);
            var lines = text.trim().split('\n').reverse();
            var players = {};
            var currentRounds = {};
            var rounds = [];
            var segmentsBuilt = {};
            var segmentsCost = {};
            var loadsDelivered = {};
            var loadsRevenue = {};
            var milepostsMoved = {};
            var actionsByRound = {};
            var timesPitched = {};
            // declare an array to record when a player upgrades a train
            var graphAnnotations = []; 

            lines.forEach(line => {
                var parts = line.split('\t');
                var round = parts[0];
                var player = parts[1];
                var action = parts[2];

                if (!players[player]) {
                    players[player] = { money: startingMoney, history: [] };
                    currentRounds[player] = null;
                    segmentsBuilt[player] = 0;
                    segmentsCost[player] = 0;
                    loadsDelivered[player] = 0;
                    loadsRevenue[player] = 0;
                    milepostsMoved[player] = 0;
                    timesPitched[player] = 0;
                    graphAnnotations[player] = null;
                }

                // account for instances where a player does a NOOP
                // update player to the current round
                while (currentRounds[player] < round) {
                    players[player].history.push(players[player].money);
                    currentRounds[player]++;
                }
                
                if (action.startsWith("Built")) {
                    var cost = parseAmount(action);
                    players[player].money -= cost;
                    segmentsBuilt[player] += parseSegments(action);
                    segmentsCost[player] += cost;
                } else if (action.startsWith("Upgraded")) {
                    players[player].money -= parseAmount(action);
                    var playerKeys = Object.keys(players);
                    var playerIndex = playerKeys.indexOf(player);
                    var topLine = 100.0;
                    var spacing = 10.0; // adjust this value to change the spacing
                    var yMin = topLine - (playerIndex * spacing);
                    var yMax = 0;
                    graphAnnotations.push({
                        type: 'line',
                        id: 'vline' + round, // unique id for the annotation
                        options: {
                            borderDash: [2, 2],
                            borderColor: 'black',
                            borderWidth: 2,
                        },
                        value: round,
                        yMin: yMin,
                        yMax: yMax,
                        label: {
                            backgroundColor: 'rgba(0,0,0,0.3)',
                            content: player + ' Upgraded',
                            enabled: true,
                            position: 'start',
                        }
                    });
                } else if (action.startsWith("Player was taxed")) {
                    players[player].money -= parseAmount(action);
                } else if (action.startsWith("Delivered")) {
                    var revenue = parseAmount(action);
                    players[player].money += revenue;
                    loadsDelivered[player] += 1;
                    loadsRevenue[player] += revenue;
                } else if (action.startsWith("Moved")) {
                    var movement = parseMovement(action);
                    milepostsMoved[player] += movement;

                    if (action.includes("for rent to")) {
                        var rent = parseAmount(action);
                        players[player].money -= rent;
                        var recipient = action.split("for rent to")[1].trim();
                        if (recipient && recipient in players) {
                            while (currentRounds[recipient] < round) {
                                players[recipient].history.push(players[recipient].money);
                                currentRounds[recipient]++;
                            }
                            players[recipient].money += rent;                       
                        }
                    }
                } else if (action.startsWith("Pitched")) {
                    timesPitched[player] += 1;
                }

                if (!rounds.includes(round)) {
                    rounds.push(round);
                }
                if (!actionsByRound[round]) {
                    actionsByRound[round] = [];
                }
                actionsByRound[round].push(player + " " + action);
            });

            // Add the final money totals for each player
            for (var player in players) {
                while (currentRounds[player] < rounds.length + 1 ) {
                    players[player].history.push(players[player].money);
                    currentRounds[player]++;
                }
            }

            var statsText = "";
            var winner = Object.keys(players).reduce((a, b) => players[a].money > players[b].money ? a : b);
            var gameIsOver = Object.values(players).some(player => player.money > 250);

            if (gameIsOver) {
                statsText += "There were " + (rounds.length) + " rounds, and ";
                statsText += "the winner was " + winner + ".<br>";
            } else {
                statsText += "So far, there have been " + (rounds.length) + " rounds, and ";
                statsText += "the current leader is " + winner + ".<br>";
            }

            statsText += "<table style='border-spacing: 10px;'><tr><th style='text-align: left;'>Player</th><th style='text-align: left;'>Balance</th><th style='text-align: left;'>Segments<br>Built</th><th style='text-align: left;'>Track<br>Cost</th><th style='text-align: left;'>Loads<br>Delivered</th><th style='text-align: left;'>Load<br>Revenue</th><th style='text-align: left;'>Mileposts<br>Moved</th><th style='text-align: left;'>Times<br>Pitched</th><th style='text-align: left;'>Revenue per<br>Segment</th><th style='text-align: left;'>$ Earned per<br>$ Spent</th><th style='text-align: left;'>Mag's Coefficient<br>$ earned / $ spent per segment</th></tr>";
            for (var player in players) {
                statsText += 
                    "<tr><td style='text-align: left;'>" + player + 
                    "</td><td style='text-align: left;'>$" + players[player].money +
                    "</td><td style='text-align: left;'>" + segmentsBuilt[player] + 
                    "</td><td style='text-align: left;'>$" + segmentsCost[player] + 
                    "</td><td style='text-align: left;'>" + loadsDelivered[player] + 
                    "</td><td style='text-align: left;'>$" + loadsRevenue[player] + 
                    "</td><td style='text-align: left;'>" + milepostsMoved[player] + 
                    "</td><td style='text-align: left;'>" + timesPitched[player] + 
                    "</td><td style='text-align: left;'>$" + (loadsRevenue[player]/segmentsBuilt[player]).toFixed(2) + 
                    "</td><td style='text-align: left;'>" + (loadsRevenue[player]/segmentsCost[player]).toFixed(2) + 
                    "</td><td style='text-align: left;'>" + (loadsRevenue[player]*segmentsBuilt[player]/segmentsCost[player]).toFixed(2) + 
                    "</td></tr>";
            }
            statsText += "</table>";            
            document.getElementById('stats').innerHTML = statsText;

            var datasets = [];
            var colors = ['blue', 'red', 'orange', 'yellow', 'green', 'purple', 'black', 'pink'];
            var colorIndex = 0;
            for (var player in players) {
                datasets.push({
                    label: player,
                    data: players[player].history,
                    fill: false,
                    borderColor: colors[colorIndex % colors.length],
                });
                colorIndex++;
            }
            
            var ctx = document.getElementById('myChart').getContext('2d');
            if (myGameChart) {
                myGameChart.destroy();
            }
            myGameChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rounds[0] === "0" ? rounds : [0].concat(rounds),
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Round'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Money'
                            }
                        },
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Player Money Each Round'
                        },
                        tooltip: {
                            callbacks: {
                                footer: function(tooltipItem) {
                                    var round = tooltipItem[0].dataIndex;
                                    return actionsByRound[round];
                                }
                            }
                        },
                        annotation: {
                            annotations: graphAnnotations.map(annotation => ({
                                ...annotation,
                                xMin: annotation.value,
                                xMax: annotation.value,
                                borderColor: annotation.options.borderColor,
                                borderWidth: annotation.options.borderWidth,
                                borderDash: annotation.options.borderDash,
                                label: {
                                    ...annotation.label,
                                    position: 'start',
                                    backgroundColor: 'rgba(0,0,0,0.9)',
                                    content: annotation.label.content,
                                    enabled: true
                                }
                            }))
                        }
                    }
                }
            });
        
            var showAnnotations = true;

            document.getElementById('toggle-annotations').addEventListener('click', function() {
                showAnnotations = !showAnnotations;
                myGameChart.options.plugins.annotation.annotations.forEach(function(annotation) {
                    annotation.display = showAnnotations;
                });
                myGameChart.update();
            });
        }
    </script>
</body>
</html>
